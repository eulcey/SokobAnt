(in-package :sokob-ant)

(defvar *player-position* (gamekit:vec2 3 3))
(defvar *pressed-directions* (list nil nil nil nil))
(defvar *last-direction* :up)
(defvar *pressed-enter* nil)
(defvar *paused* nil)

(defun move-up ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :up))
    (setf (car *pressed-directions*) t)))

(defun move-down ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :down))
    (setf (cadr *pressed-directions*) t)))

(defun move-right ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :right))
    (setf (caddr *pressed-directions*) t)))

(defun move-left ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :left))
    (setf (cadddr *pressed-directions*) t)))

(defun init-controls ()
  (gamekit:bind-button :up :pressed #'move-up)
  (gamekit:bind-button :up :repeating #'move-up)
  (gamekit:bind-button :up :released (lambda () (setf (car *pressed-directions*) nil)))
  (gamekit:bind-button :down :pressed #'move-down)
  (gamekit:bind-button :down :repeating #'move-down)
  (gamekit:bind-button :down :released (lambda () (setf (cadr *pressed-directions*) nil)))
  (gamekit:bind-button :right :pressed #'move-right)
  (gamekit:bind-button :right :repeating #'move-right)
  (gamekit:bind-button :right :released (lambda () (setf (caddr *pressed-directions*) nil)))
  (gamekit:bind-button :left :pressed #'move-left)
  (gamekit:bind-button :left :repeating #'move-left)
  (gamekit:bind-button :left :released (lambda () (setf (cadddr *pressed-directions*) nil)))
  (gamekit:bind-button :enter :pressed (lambda () (setf *pressed-enter* t)))
  (gamekit:bind-button :escape :pressed (lambda () (when (eql (car *game-state*) :level)
						     (setf *paused* t))))
  (gamekit:bind-button :r :pressed (lambda () (reset-positions))))

(defun draw-player (rotation position)
  (let ((real-x (+ (* *tile-size* (gamekit:x position)) 16))
	(real-y (+ (* *tile-size* (gamekit:y position)) 16)))
    (gamekit:scale-canvas 2.0 2.0)
    (gamekit:translate-canvas real-x real-y )
    (gamekit:rotate-canvas rotation)
    (gamekit:draw-image (gamekit:vec2 -16 -16) :player-ant)
    (gamekit:rotate-canvas (- rotation))
    (gamekit:translate-canvas (- real-x) (- real-y))
    (gamekit:scale-canvas 0.5 0.5)))

(defun push-object (object push-vector)
  (setf (caddr object)
	(calc-new-obj-pos object push-vector)))

(defun obj-can-be-pushed (object push-dir level items)
  (let ((new-pos (calc-new-obj-pos object push-dir)))
    (and (all-tiles-free level new-pos)
	 (not (another-object-on-same-tile (list (get-object-id object)
						 (get-object-type object)
						 new-pos)
					   items)))))

(defun pos-is-in-list (position lst)
  (if (not lst)
      nil
      (if (and (= (gamekit:x position) (gamekit:x (car lst)))
	       (= (gamekit:y position) (gamekit:y (car lst))))
	  t
	  (pos-is-in-list position (cdr lst)))))

(defun target-is-all-occupied (pos target-pos)
  (if (not target-pos)
      t
      (let ((first-target (car target-pos)))
	(if (pos-is-in-list first-target pos)
	    (target-is-all-occupied pos (cdr target-pos))
	    nil))))

(defun item-fits-target (item target)
  (let ((item-pos (get-object-position item))
	(target-pos (get-object-position target)))
    (target-is-all-occupied item-pos target-pos)))

(defun remove-target-if-fits (item targets)
  (reduce (lambda (coll a) (if (not (item-fits-target item a))
			       (cons a coll))) targets :initial-value nil))

(defun state-is-win-condition (items targets)
  (if (not targets)
      t
      (if (not (eql (not targets) (not items)))
	  nil
	  (let ((item (car items)))
	    (let ((rest-targets (remove-target-if-fits item targets)))
	      (state-is-win-condition (cdr items) rest-targets))))))

(defun is-goal-item (item)
  (let ((item-type (get-object-type item)))
    (or (eql item-type :aphid)
	(eql item-type :default-leaf))))

(defun get-goal-items (items)
  (reduce (lambda (result item)
	    (if (is-goal-item item)
		(cons item result)
		result))
	  items
	  :initial-value nil))
	  
(defun handle-player-move (level items targets)
  (if (not *paused*)
      (let ((new-x (if (caddr *pressed-directions*)
		       (1+ (gamekit:x *player-position*))
		       (if (cadddr *pressed-directions*)
			   (1- (gamekit:x *player-position*))
			   (gamekit:x *player-position*))))
	    (new-y (if (car *pressed-directions*)
		       (1+ (gamekit:y *player-position*))
		       (if (cadr *pressed-directions*)
			   (1- (gamekit:y *player-position*))
			   (gamekit:y *player-position*)))))
	(when (not (every #'not *pressed-directions*))
	  (let ((new-position (gamekit:vec2 new-x new-y)))
	    (if (eql (get-tile level new-position) :free)
		(let ((obj (get-object items new-position)))
		  (if (not obj) ; tile is completely free, player can move
		      (player-move new-x new-y)
		      (let ((push-dir (gamekit:subt new-position *player-position*)))
		      (when (obj-can-be-pushed obj push-dir
					       level items)
			(push-object obj push-dir)
			(player-move new-x new-y)))))))
	  (setf *pressed-directions* (list nil nil nil nil)))
	(if (state-is-win-condition (get-goal-items items) targets)
	    (show-level-completed)))
      (progn
	(setf *game-state* *paused-state*)
	(setf *paused* nil)
	(setf *selected-option* :continue))))

(defun player-move (x y)
  (setf (gamekit:x *player-position*) x)
  (setf (gamekit:y *player-position*) y)
  (gamekit:play-sound :step-sound))
